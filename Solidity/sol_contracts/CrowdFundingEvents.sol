// Refer references from "Node JS & Solidity References.pdf" in root folder of this application

// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

//Main contract used for creating subcontracts
contract CrowdfundingEvents{
    address public crowdfunding_admin;//Crowdfunding events contract creator admin
    crowd_funding_event[] public crowdFundingEventAddresses;// array to store created fundraising events

    struct crowd_funding_event {   //struct code similar to classes in Object Oriented Programming
        string crowdfunding_event_title;//fundraiser title
        string crowdfunding_event_content;//fundraiser content
        address crowdfunding_event_address;//fundraiser contract address generated by the blockchain network
        address crowdfunding_event_manager_address;//fundraiser manager wallet address
        uint crowdfunding_event_min_deposit;//fundraiser minimum deposit value
    }

    constructor(){
        crowdfunding_admin = msg.sender;  //stores contract deployer wallet address
    }

    //creates fundraising events using CrowdfundingEvent subcontract
    function CreateCrowdfundingEvent(
        string memory _crowdfunding_event_title, //sent by fundraising creator
        string memory _crowdfunding_event_content, //sent by fundraising creator
        uint _crowdfunding_event_min_deposit) ////sent by fundraising creator
        public{

        address _crowdfunding_event_address = address(//deploys a new fundraiser event and stores the address in an array
            new CrowdfundingEvent(
                _crowdfunding_event_title, //fundraiser title set by fund manager
                _crowdfunding_event_content, //fundraiser content set by fund manager
                msg.sender, //fundraiser manager wallet address fetched at the time of CrowdfundingEvent contract deployment
                _crowdfunding_event_min_deposit//fundraiser minimum deposit value set by fund manager
                ));
        crowdFundingEventAddresses.push(// stores data in a dynamic array
            crowd_funding_event(
                _crowdfunding_event_title,//store fundraiser title set by fund manager
                _crowdfunding_event_content,//store fundraiser content set by fund manager
                _crowdfunding_event_address,//store fundraiser contract address generated by the blockchain network
                msg.sender,//store fundraiser manager wallet address fetched at the time of CrowdfundingEvent contract deployment
                _crowdfunding_event_min_deposit// store fundraiser minimum deposit value
            ));
    }

    //used to fetch all the fundraising events created using this main contract CrowdfundingEvents
    function GetCrowdfundingEvents() public view returns (crowd_funding_event[] memory){
        return crowdFundingEventAddresses; // returns all the contracts details
    }

}

//create a fundraising event and stores it in the respective blockchain network
contract CrowdfundingEvent{

    //variables to store fundraising event details at the time of contract creation
    string public crowdfunding_event_title; //fundraiser title set by fund manager
    string public crowdfunding_event_content; //fundraiser content set by fund manager
    address public crowdfunding_event_manager_address;  //fund manager address set by the main contract
    uint public crowdfunding_event_min_deposit; //fundraiser min deposit value set by fund manager

    contributor_details[] public contributors_details;  //dynamic array to store fundraising event contributor details
    mapping(address => uint) public contributor_votes;  //mapping to store the number of votes assigned to a contributor
   
    uint public total_votes = 0;    //stores the total number of votes
    voting_event[] public voting_events;    //stores all the voting/refund events created in the fundraiser
    voting_address_status[] voting_event_address_status; // stores the yes/no votes casted by each contributor for the respective voting/refund event

    discussion_forum[] public discussions;  // stores all the discussion held for the fundraiser and voting/refund events

    mapping(address => bool) public contributor_already_created_refund_event; // stores if a contributor has already created a refund event
    bool public refund_event_active; //check for storing any active refund event in contract
    uint public refund_event_fundbalance; //store fundraiser remaining balance at the time of any refund event creation
    bool public refund_event_success;   //check for refund event success status in contract
    mapping(address => bool) public contributor_already_claimed_refund; // mapping check for storing claimed refunds data
    
    //used for storing fundraiser events contributors details
    struct contributor_details{//struct code similar to classes in Object Oriented Programming
        address contributor_address;
        uint contributor_votes;
    }

    //used for storing each voting/refund event details
    struct voting_event{//struct code similar to classes in Object Oriented Programming
        string title;  //Voting/refund event title data
        string body;    //Voting/refund event body data
        address payable destination_wallet_address; //destination wallet address assigned by the fund manager
        uint amount_to_send;    // amount of ether which the funf manager wants to sent
        bool event_success_status;  //voting/refund event success status
        bool event_completion_status;   // voting/refund event completion status
        uint yes_votes; // for adding and storing yes votes polled by contributors
        uint no_votes; // for adding and storing no votes polled by contributors
        voting_address_status_array[] polling_data; //dynamic array for storing all the yes/no votes of the voting/refund event
        bool refund_event;  //flag to check if this event is voting/refund event
    }

    struct voting_address_status_array//struct code similar to classes in Object Oriented Programming
    {
        address contributor_address;// contributors address
        bool contributor_vote_status;// contributors yes/no vote
    }

    struct voting_address_status{//struct code similar to classes in Object Oriented Programming
        mapping(address => bool) address_voting_status; // contributors yes/no vote stores in mapping
    }

    struct discussion_forum{//struct code similar to classes in Object Oriented Programming
        uint index;     // index of the submitted comment
        address comment_address;    // commentors address
        string comment;     // commentors comment
        uint rating;       //commentors rating
    }

    // gets triggered at the time of contract creation
    constructor(
        string memory _crowdfunding_event_title, // fundraiser title
        string memory _crowdfunding_event_content, // fundraiser description
        address _crowdfunding_event_manager_address, // fund manger address
        uint _crowdfunding_event_min_deposit) // deposit value set by fund manager
    {
        crowdfunding_event_title = _crowdfunding_event_title;   //passes down from the main contract
        crowdfunding_event_content = _crowdfunding_event_content; //passes down from the main contract
        crowdfunding_event_manager_address = _crowdfunding_event_manager_address; //passes down from the main contract
        crowdfunding_event_min_deposit = _crowdfunding_event_min_deposit; //passes down from the main contract
    }
    

    function GetVotingEvents() public view returns (voting_event[] memory){
        return voting_events; // function to retrieve all voting/refund events
    }

    function GetCrowdfundingDiscussionForum() public view returns (discussion_forum[] memory){
        return discussions; // function to retrieve all discussion forms
    }

    function GetCrowdfundingEventDetails() public view returns (
        string memory, 
        string memory, 
        address, 
        uint, 
        contributor_details[] memory, 
        uint, 
        uint, 
        uint){ // function to return the fundraiser event details
        return (
            crowdfunding_event_title, //title of the fundraiser set by the fund manager
            crowdfunding_event_content, //content/description of the fundraiser set by the fund manager
            crowdfunding_event_manager_address, // fund manager eth wallet address
            crowdfunding_event_min_deposit, // minimum entry value set by the fund manager
            contributors_details,   //array which has all the contributor details
            total_votes,    // total votes allowed on the fundraiser
            address(this).balance,  // total money present in the fundraiser
            voting_events.length);  //no of voting/refund events in the fundraiser
    }

    function DepositToCrowdfundingEvent() public payable {  //function to make contributions to the fundraiser
        require(voting_events.length == 0, 'No new contributions are accepted upon the start of voting/refund events');    // flag to reject new contributors upon start of first voting/refund event
        require(msg.value >= crowdfunding_event_min_deposit, 'Deposit value less than minimum offer value set by the fundraiser');    //flag to reject contributions made less than minimum value
        require(msg.value % crowdfunding_event_min_deposit == 0, 'Deposit value not in multiples of minimum offer value set by the fundraiser');  //flag to reject contributions not made in multiples of minimum value
        require(contributor_votes[msg.sender] == 0,'You have already contributed to the fundraiser');    // flag to reject contributors trying to contribute again 
        contributor_votes[msg.sender] = msg.value / crowdfunding_event_min_deposit; // calculating no of votes a contributor gets
        contributors_details.push(  // store contributor details in an array
            contributor_details(
                msg.sender, //contributor address
                contributor_votes[msg.sender]   //contributor votes
            )
        );
        total_votes = total_votes + contributor_votes[msg.sender];  // adding all the contributor votes to know the total votes
    }

    function CreateAnVotingEvent(
        string memory title, //voting/refund event title
        string memory body, //voting/refund event description
        address payable destination_wallet_address, //destination wallet address
        uint amount_to_send, //amount the manager wants to send to a destination wallet
        bool refund_event) ////flag to check if it is a voting/refund event
        public 
        RefundVoteSuccess   //// function modifier to check if refund_event_success is active
    {   // function to create voting and refund events
            require(crowdfunding_event_manager_address == msg.sender || (refund_event == true && contributor_votes[msg.sender] > 0), 'Only managers can create voting/refund requests, contributors are only allowed to create refund requests');//flag to allow fund manager/contributor to create voting/refund events
            require(refund_event_active == false, 'No new events can be created when a refund event is active');   // flag to check if there are any active refund events
            require(contributor_already_created_refund_event[msg.sender] == false, 'Contributor has already created a failed refund event before'); //flag to check if a contributor already created a refund event
            require(address(this).balance >= amount_to_send, 'This fundraiser has less money than the amount you want to send');// flag to check if fund manager is setting a amount more than the amount left in the fundraiser
            require(address(this).balance > 0, 'This fundraiser has no money to create new voting events'); // flag to check if fundraiser is out of money
            voting_event storage temp = voting_events.push();//creates a new refund event and stores in the voting/refund events array
            temp.title = title; //voting event title
            temp.body = body;   //voting event description
            temp.destination_wallet_address = destination_wallet_address;   // destination wallet address set by the fund manager
            temp.amount_to_send = amount_to_send;   //amount the fundmanger wants to send to the destination wallet
 
            if(refund_event == true){   //these variable are assigned different values if it is a refund event
                temp.refund_event = true;   // refund event flag is set to true
                refund_event_active = true; // refund event active flag is set to true
                refund_event_fundbalance = address(this).balance;   //the whole amount left in the fundraiser is set for refund
                contributor_already_created_refund_event[msg.sender] = true;    // contributor is flagged to not allow him/her to create refund events more than once
            }

            voting_address_status storage temp2= voting_event_address_status.push();    // mapping array to check if a contributor has voted for a specific voting/refund event
    }

    function VoteForVotingEvent(uint voting_event_index, bool vote) ////function to cast a vote for a voting/refund event
        public 
        RefundVoteSuccess   //// function modifier to check if refund_event_success is active
        {
            require(voting_events[voting_event_index].event_completion_status == false, 'Voting/refund event already completed' );//flag to check if a voting/refund event is closed
            require(contributor_votes[msg.sender] > 0,'You cannot vote as you did not contribute to the fundraiser');//flag to check if the voter is a contributor to the fundraiser
            require(voting_event_address_status[voting_event_index].address_voting_status[msg.sender] == false , 'You have already voted for the voting/refund event');// flag to check if the contributor has already voted for a voting/refund event

            vote ? voting_events[voting_event_index].yes_votes = voting_events[voting_event_index].yes_votes + contributor_votes[msg.sender]    // adds all the yes votes voted for a voting/refund event
                : voting_events[voting_event_index].no_votes = voting_events[voting_event_index].no_votes + contributor_votes[msg.sender];   // adds all the no votes voted for a voting/refund event
            voting_event_address_status[voting_event_index].address_voting_status[msg.sender] = true;   // flag is set to true if a contributor has voted for a voting/refund
            voting_events[voting_event_index].polling_data.push(
                voting_address_status_array( //stored the polled data in an array
                    msg.sender, //storing contributor address
                    vote    //storing contributor yes/no vote
                )
            );
    }

    function CompleteVotingEvent (uint voting_event_index) ////function to close polling for a voting/refund event
        public 
        RefundVoteSuccess   //// function modifier to check if refund_event_success is active
    {
        require(address(this).balance >= voting_events[voting_event_index].amount_to_send || refund_event_active == true, 'This fundraiser has less money than the amount set at the creation of this voting request' ); //flag to check if fundraiser has enough money or if it is a refund event
        require(voting_events[voting_event_index].event_completion_status == false, 'Voting event already completed' );//flag to check if a voting/refund event is closed
        require(voting_events[voting_event_index].yes_votes > (total_votes / 2) 
                    || voting_events[voting_event_index].no_votes > (total_votes / 2)
                        , 'more than 50% votes should say yes/no to send/reject ethereum transfer'); // flag to check if more than 50% of the votes for a voting/refund event are yes/no 

        if(voting_events[voting_event_index].yes_votes > (total_votes / 2)) // flag to check if more than 50% votes are yes
        {
            if(voting_events[voting_event_index].refund_event)// flag to check if voting/refund event is a refund event
            {
                refund_event_success = true;// whole fundraiser left over money is set for refund
            }
            else
            {
                voting_events[voting_event_index].destination_wallet_address.transfer(voting_events[voting_event_index].amount_to_send);// amount set by manager to send to a destination address is sent.
            }
            voting_events[voting_event_index].event_success_status = true; // flag set to true if voting/refund event is successfull
        }

        if(voting_events[voting_event_index].refund_event) // flag to check if voting/refund event is a refund event
            {
                refund_event_active = false; //fundraiser refund event active flag is set to false
            }
        
        voting_events[voting_event_index].event_completion_status = true;   // flag set to true if a voting/refund event is completed
    }

    //function to store contributor/manager discussions
    function CrowdfundingDiscussionForum(uint index,string memory comment, uint rating) public{
        require(contributor_votes[msg.sender] > 0 ,'You cannot comment as you are not a contributor of the fundraiser');//flag to check if the commentor is a contributor of the fundraiser
        discussions.push(
            discussion_forum(
                index,  //index to know in which area of the application the comments are made
                msg.sender, // contributors address
                comment,    // commentor's comment
                rating  // commentor's rating
            )
        );
    }

    // function modifier to check if the fundraiser is set for refund success
    modifier RefundVoteSuccess(){
        require(refund_event_success == false, 'This fundraiser has failed and is marked for refund, contributors can start claiming their left over ethereum from this fundraiser' );
        _;
    }

    //function to claim refunds in a fundraiser
    function ClaimRefund() public{
        require(refund_event_success == true, 'This fundraiser is still ongoing..!!' );//flag to check if the fundraiser is set for refund
        require(contributor_votes[msg.sender] > 0,'You cannot claim a refund if you are not a contributor');//flag to check if the person claiming a refund is a contributor
        require(contributor_already_claimed_refund[msg.sender] == false, 'You have already claimed your refund..!!' ); // flag to check if a contributor has claimed refund
        
        payable(msg.sender).transfer((refund_event_fundbalance * contributor_votes[msg.sender])/total_votes);// amount is refunded proportionately to the contributor as per their contibution 
        contributor_already_claimed_refund[msg.sender] = true;//flag is set to true if a contributor has claimed refund
    }
}
