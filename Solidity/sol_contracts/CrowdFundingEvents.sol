// Refer references from "Node JS & Solidity References.pdf" in root folder of this application

// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

//Main contract used for creating new instances of fundraiser contract
contract CrowdfundingEvents
{

    address public crowdfunding_admin;//Crowdfunding events contract creator admin
    crowd_funding_event[] public crowdFundingEventAddresses;// array to store created fundraising events

    //struct code similar to classes in Object Oriented Programming
    struct crowd_funding_event 
    { 
        string crowdfunding_event_title;//fundraiser title
        string crowdfunding_event_content;//fundraiser content
        address crowdfunding_event_address;//fundraiser contract address generated by the blockchain network
        address crowdfunding_event_manager_address;//fundraiser manager wallet address
        uint crowdfunding_event_min_deposit;//fundraiser minimum deposit value
    }

    //stores contract deployer wallet address
    constructor()
    {
        crowdfunding_admin = msg.sender;  
    }

    //creates fundraising events using CrowdfundingEvent subcontract
    function CreateCrowdfundingEvent(
        string memory _crowdfunding_event_title, //sent by fundraising creator
        string memory _crowdfunding_event_content, //sent by fundraising creator
        uint _crowdfunding_event_min_deposit) ////sent by fundraising creator
        public
    {

        address _crowdfunding_event_address = address(//deploys a new fundraiser event and stores the address in an array
            new CrowdfundingEvent(
                _crowdfunding_event_title, //fundraiser title set by fund manager
                _crowdfunding_event_content, //fundraiser content set by fund manager
                msg.sender, //fundraiser manager wallet address fetched at the time of CrowdfundingEvent contract deployment
                _crowdfunding_event_min_deposit//fundraiser minimum deposit value set by fund manager
                ));
        crowdFundingEventAddresses.push(// stores data in a dynamic array
            crowd_funding_event(
                _crowdfunding_event_title,//store fundraiser title set by fund manager
                _crowdfunding_event_content,//store fundraiser content set by fund manager
                _crowdfunding_event_address,//store fundraiser contract address generated by the blockchain network
                msg.sender,//store fundraiser manager wallet address fetched at the time of CrowdfundingEvent contract deployment
                _crowdfunding_event_min_deposit// store fundraiser minimum deposit value
            ));
    }

    //used to fetch all the fundraising events created using this main contract CrowdfundingEvents
    function GetCrowdfundingEvents() public view returns (crowd_funding_event[] memory)
    {
        return crowdFundingEventAddresses; // returns all the contracts details
    }

}

//creates a fundraiser and stores it in the respective blockchain network
contract CrowdfundingEvent
{

    //variables to store fundraiser details at the time of contract creation
    string public crowdfunding_event_title; //fundraiser title set by fund manager
    string public crowdfunding_event_content; //fundraiser content set by fund manager
    address public crowdfunding_event_manager_address;  //fund manager address set by the main contract on the instance creation of this contract
    uint public crowdfunding_event_min_deposit; //fundraiser min deposit value set by fund manager

    contributor_details[] public contributors_details;  //dynamic array to store fundraising event contributor details
    mapping(address => uint) public contributor_votes;  //mapping to store the number of votes assigned to a contributor
   
    uint public total_votes = 0;    //stores the total number of votes
    voting_event[] public voting_events;    //stores all the disbursal/refund requests created in the fundraiser
    voting_address_status[] voting_event_address_status; // stores the yes/no votes casted by each contributor for the respective disbursal/refund request

    discussion_forum[] public discussions;  // stores all the discussion held for the fundraiser and disbursal/refund requests

    mapping(address => bool) public contributor_already_created_refund_event; // stores if a contributor has already created a refund request
    bool public refund_event_active; //check for storing any active refund request in contract
    uint public refund_event_fundbalance; //store fundraiser remaining balance at the time of any refund request creation
    bool public refund_event_success;   //check for refund request success status in contract
    mapping(address => bool) public contributor_already_claimed_refund; // mapping check for storing claimed refunds data
    
    //used for storing fundraiser events contributors details
    //struct code similar to classes in Object Oriented Programming
    struct contributor_details
    {
        address contributor_address;
        uint contributor_votes;
    }

    //used for storing each disbursal/refund request details
    //struct code similar to classes in Object Oriented Programming
    struct voting_event
    {
        string title;  //disbursal/refund request title data
        string body;    //disbursal/refund request body data
        address payable destination_wallet_address; //destination wallet address assigned by the fund manager
        uint amount_to_send;    // amount of ether which the funf manager wants to sent
        bool event_success_status;  //disbursal/refund request success status
        bool event_completion_status;   // disbursal/refund request completion status
        uint yes_votes; // for adding and storing yes votes polled by contributors
        uint no_votes; // for adding and storing no votes polled by contributors
        voting_address_status_array[] polling_data; //dynamic array for storing all the yes/no votes of the disbursal/refund request
        bool refund_event;  //flag to check if this event is disbursal/refund request
    }

    //struct code similar to classes in Object Oriented Programming
    struct voting_address_status_array
    {
        address contributor_address;// contributors address
        bool contributor_vote_status;// contributors yes/no vote
    }

    //struct code similar to classes in Object Oriented Programming
    struct voting_address_status
    {
        mapping(address => bool) address_voting_status; // contributors yes/no vote stores in mapping
    }

    //struct code similar to classes in Object Oriented Programming
    struct discussion_forum
    {
        uint index;     // index of the submitted comment
        address comment_address;    // commentors address
        string comment;     // commentors comment
        uint rating;       //commentors rating
    }

    // gets triggered at the time of contract creation
    constructor(
        string memory _crowdfunding_event_title, // fundraiser title
        string memory _crowdfunding_event_content, // fundraiser description
        address _crowdfunding_event_manager_address, // fund manger address
        uint _crowdfunding_event_min_deposit) // deposit value set by fund manager
    {
        crowdfunding_event_title = _crowdfunding_event_title;   //passes down from the main contract
        crowdfunding_event_content = _crowdfunding_event_content; //passes down from the main contract
        crowdfunding_event_manager_address = _crowdfunding_event_manager_address; //passes down from the main contract
        crowdfunding_event_min_deposit = _crowdfunding_event_min_deposit; //passes down from the main contract
    }
    
    // function to retrieve all disbursal/refund requests
    function GetVotingEvents() public view returns (voting_event[] memory)
    {
        return voting_events; 
    }

    // function to retrieve all discussion forms
    function GetCrowdfundingDiscussionForum() public view returns (discussion_forum[] memory)
    {
        return discussions; 
    }

    // function to return the fundraiser event details
    function GetCrowdfundingEventDetails() public view returns (
        string memory, string memory, address, uint, contributor_details[] memory, uint, uint, uint)
    { 
        return (
            crowdfunding_event_title, //title of the fundraiser set by the fund manager
            crowdfunding_event_content, //content/description of the fundraiser set by the fund manager
            crowdfunding_event_manager_address, // fund manager eth wallet address
            crowdfunding_event_min_deposit, // minimum entry value set by the fund manager
            contributors_details,   //array which has all the contributor details
            total_votes,    // total votes allowed on the fundraiser
            address(this).balance,  // total Ether present in the fundraiser
            voting_events.length);  //no of disbursal/refund requests in the fundraiser
    }

    //function to make contributions to the fundraiser
    function DepositToCrowdfundingEvent() public payable 
    {  
        // flag to reject new contributors upon start of first disbursal/refund requests
        require(voting_events.length == 0, 'No new contributions are accepted upon the start of disbursal/refund requests');
        //flag to reject contributions made less than minimum value    
        require(msg.value >= crowdfunding_event_min_deposit, 'Deposit value less than the minimum contribution value set in the fundraiser');
        //flag to reject contributions not made in multiples of minimum value    
        require(msg.value % crowdfunding_event_min_deposit == 0, 'Deposit value not in multiples of the minimum contribution value set in the fundraiser');
        // flag to reject contributors trying to contribute again  
        require(contributor_votes[msg.sender] == 0,'You have already contributed to the fundraiser');     
        contributor_votes[msg.sender] = msg.value / crowdfunding_event_min_deposit; // calculating no of votes a contributor gets
        contributors_details.push(  // store contributor details in an array
            contributor_details(
                msg.sender, //contributor address
                contributor_votes[msg.sender]   //contributor votes
            )
        );
        total_votes = total_votes + contributor_votes[msg.sender];  // adding all the contributor votes to know the total votes
    }

    // function to create disbursal and refund requests
    function CreateAnVotingEvent(
        string memory title, //disbursal/refund request title
        string memory body, //disbursal/refund request description
        address payable destination_wallet_address, //destination wallet address
        uint amount_to_send, //amount the manager wants to send to a destination wallet
        bool refund_event) ////flag to check if it is a disbursal/refund request
        public 
        RefundVoteSuccess   //// function modifier to check if refund_event_success is active
    {   
            //flag to allow fund manager/contributor to create disbursal/refund requests
            require(crowdfunding_event_manager_address == msg.sender || (refund_event == true && contributor_votes[msg.sender] > 0), 
            'Only managers can create disbursal/refund requests, contributors are only allowed to create refund requests');
            // flag to check if there are any active refund requests
            require(refund_event_active == false, 'No new requests can be created when a refund request is active'); 
            //flag to check if a contributor already created a refund request  
            require(contributor_already_created_refund_event[msg.sender] == false, 'Contributor has already created a failed refund request previously');
            // flag to check if fund manager is setting a amount more than the amount left in the fundraiser
            require(address(this).balance >= amount_to_send, 'This fundraiser has less Ether than the amount you want to send');
            // flag to check if fundraiser is out of Ether
            require(address(this).balance > 0, 'This fundraiser has no Ether to create new disbursal requests'); 
            voting_event storage temp = voting_events.push();//creates a new refund request and stores in the disbursal/refund requests array
            temp.title = title; //disbursal/refund request title
            temp.body = body;   //disbursal/refund request description
            temp.destination_wallet_address = destination_wallet_address;   // destination wallet address set by the fund manager
            temp.amount_to_send = amount_to_send;   //amount the fundmanger wants to send to the destination wallet
 
            if(refund_event == true){   //these variable are assigned different values if it is a refund request
                temp.refund_event = true;   // refund request flag is set to true
                refund_event_active = true; // refund request active flag is set to true
                refund_event_fundbalance = address(this).balance;   //the whole amount left in the fundraiser is set for refund
                contributor_already_created_refund_event[msg.sender] = true;// contributor is flagged to not allow him/her to create refund requests more than once
            }

            // mapping array to check if a contributor has voted for a specific disbursal/refund request
            voting_address_status storage temp2= voting_event_address_status.push();    
    }

    //function to cast a vote for a disbursal/refund request
    function VoteForVotingEvent(uint voting_event_index, bool vote) 
        public 
        RefundVoteSuccess   //// function modifier to check if refund_event_success is active
    {
        //flag to check if a disbursal/refund request is closed
        require(voting_events[voting_event_index].event_completion_status == false, 'Disbursal/refund request already completed' );
        //flag to check if the voter is a contributor to the fundraiser
        require(contributor_votes[msg.sender] > 0,'You cannot vote as you did not contribute to the fundraiser');
        // flag to check if the contributor has already voted for a disbursal/refund request
        require(voting_event_address_status[voting_event_index].address_voting_status[msg.sender] == false , 'You have already voted for the disbursal/refund request');

        vote ? 
            // adds all the yes votes voted for a disbursal/refund request
            voting_events[voting_event_index].yes_votes = voting_events[voting_event_index].yes_votes + contributor_votes[msg.sender]
                : // adds all the no votes voted for a disbursal/refund request   
                 voting_events[voting_event_index].no_votes = voting_events[voting_event_index].no_votes + contributor_votes[msg.sender];
        // flag is set to true if a contributor has voted for a disbursal/refund   
        voting_event_address_status[voting_event_index].address_voting_status[msg.sender] = true;   
        voting_events[voting_event_index].polling_data.push(
            voting_address_status_array( //stored the polled data in an array
                msg.sender, //storing contributor address
                vote    //storing contributor yes/no vote
            )
        );
    }

    //function to close polling for a disbursal/refund request
    function CompleteVotingEvent (uint voting_event_index) 
        public 
        RefundVoteSuccess   //// function modifier to check if refund_event_success is active
    {
        //flag to check if fundraiser has enough Ether or if it is a refund request
        require(address(this).balance >= voting_events[voting_event_index].amount_to_send || refund_event_active == true, 
        'This fundraiser has less Ether than the amount set at the creation of this disbursal request' ); 
        //flag to check if a disbursal/refund request is closed
        require(voting_events[voting_event_index].event_completion_status == false, 'Disbursal/Refund request already completed' );
        // flag to check if more than 50% of the votes for a disbursal/refund request are yes/no 
        require(voting_events[voting_event_index].yes_votes > (total_votes / 2) 
                    || voting_events[voting_event_index].no_votes > (total_votes / 2)
                        , 'more than 50% votes should say yes/no to send/reject ethereum transfer'); 

        if(voting_events[voting_event_index].yes_votes > (total_votes / 2)) // flag to check if more than 50% votes are yes
        {
            if(voting_events[voting_event_index].refund_event)// flag to check if disbursal/refund request is a refund request
            {
                refund_event_success = true;// whole fundraiser left over money is set for refund
            }
            else
            {
                // amount set by manager to send to a destination address is sent.
                voting_events[voting_event_index].destination_wallet_address.transfer(voting_events[voting_event_index].amount_to_send);
            }
            voting_events[voting_event_index].event_success_status = true; // flag set to true if disbursal/refund request is successfull
        }
        if(voting_events[voting_event_index].refund_event) // flag to check if disbursal/refund request is a refund request
            {
                refund_event_active = false; //fundraiser refund request active flag is set to false
            }
        
        voting_events[voting_event_index].event_completion_status = true;   // flag set to true if a disbursal/refund request is completed
    }

    //function to store contributor/manager discussions
    function CrowdfundingDiscussionForum(uint index,string memory comment, uint rating) public
    {
        //flag to check if the commentor is a contributor of the fundraiser
        require(contributor_votes[msg.sender] > 0 ,'You cannot comment as you are not a contributor of the fundraiser');
        discussions.push(
            discussion_forum(
                index,  //index to know in which area of the application the comments are made
                msg.sender, // contributors address
                comment,    // commentor's comment
                rating  // commentor's rating
            )
        );
    }

    // function modifier to check if the fundraiser is set for refund success
    modifier RefundVoteSuccess()
    {   
        // flag to check if fundraiser's any refund request is successful
        require(refund_event_success == false, 
        'This fundraiser has failed and is marked for refund, contributors can start claiming their left over ethereum from this fundraiser' );
        _;
    }

    //function to claim refunds in a fundraiser
    function ClaimRefund() public{
        //flag to check if the fundraiser is set for refund
        require(refund_event_success == true, 'This fundraiser is still ongoing..!!' );
        //flag to check if the person claiming a refund is a contributor
        require(contributor_votes[msg.sender] > 0,'You cannot claim a refund if you are not a contributor');
        // flag to check if a contributor has claimed refund
        require(contributor_already_claimed_refund[msg.sender] == false, 'You have already claimed your refund..!!' ); 
        
        // amount is refunded proportionately to the contributor as per their contibution 
        payable(msg.sender).transfer((refund_event_fundbalance * contributor_votes[msg.sender])/total_votes);
        contributor_already_claimed_refund[msg.sender] = true;//flag is set to true if a contributor has claimed refund
    }
}
